@namespace CreateInvoiceSystem.Frontend.Components
@using System.Linq.Expressions
@using Microsoft.AspNetCore.Components.Forms

<div class="mb-3">
    @if (!string.IsNullOrEmpty(Label))
    {
        <label class="form-label">
            @Label
            @if (IsRequired())
            {
                <span class="text-danger ms-1" title="Pole wymagane">*</span>
            }
        </label>
    }

    <input value="@Value"
           class="@InputCssClass"
           placeholder="@Placeholder"
           disabled="@Disabled"
           @oninput="OnInput" />

    <ValidationMessage For="@ValueExpression" class="text-danger small" />

    @if (ShowValidFeedback && IsModifiedOrHasValue && !HasErrorsEffective)
    {
        <div class="valid-feedback d-block">Wygląda dobrze.</div>
    }
</div>

@code {
    [CascadingParameter] private EditContext? CascadedEditContext { get; set; }

    [Parameter] public string? Value { get; set; }
    [Parameter] public EventCallback<string?> ValueChanged { get; set; }
    [Parameter] public Expression<Func<string>>? ValueExpression { get; set; }

    [Parameter] public string? Label { get; set; }
    [Parameter] public string? Placeholder { get; set; }
    [Parameter] public bool Disabled { get; set; } = false;
    [Parameter] public bool ShowValidFeedback { get; set; } = true;

    private FieldIdentifier Field => ValueExpression != null ? FieldIdentifier.Create(ValueExpression) : default;

    private bool HasErrors => CascadedEditContext != null && ValueExpression != null && CascadedEditContext.GetValidationMessages(Field).Any();
    private bool IsModified => CascadedEditContext != null && ValueExpression != null && CascadedEditContext.IsModified(Field);
    private bool IsModifiedOrHasValue => IsModified || !string.IsNullOrWhiteSpace(Value);

    private bool HasParentErrors
    {
        get
        {
            if (CascadedEditContext == null || ValueExpression == null) return false;

            // check messages attached to the actual parent instance for this property (e.g. FieldIdentifier(addressInstance, "Street"))
            var parentInstance = GetParentInstance(ValueExpression);
            if (parentInstance == null) return false;

            var parts = GetMemberNames(ValueExpression);
            if (parts == null || parts.Length == 0) return false;

            var childName = parts.Last();
            try
            {
                var fiParentInstance = new FieldIdentifier(parentInstance, childName);
                if (CascadedEditContext.GetValidationMessages(fiParentInstance).Any())
                    return true;
            }
            catch { }

            return false;
        }
    }

    private bool HasErrorsEffective => HasErrors || HasParentErrors;

    private string InputCssClass
    {
        get
        {
            var baseClass = "form-control";
            if (CascadedEditContext == null || ValueExpression == null) return baseClass;

            if (HasErrorsEffective)
                return $"{baseClass} is-invalid";

            if (IsModifiedOrHasValue)
                return $"{baseClass} is-valid";

            return baseClass;
        }
    }

    private bool IsRequired()
    {
        if (ValueExpression == null) return false;
        MemberExpression? member = ValueExpression.Body as MemberExpression;
        if (member == null && ValueExpression.Body is UnaryExpression ue && ue.Operand is MemberExpression m) member = m;
        if (member?.Member is System.Reflection.PropertyInfo prop)
        {
            return System.Attribute.IsDefined(prop, typeof(System.ComponentModel.DataAnnotations.RequiredAttribute));
        }
        return false;
    }

    private async Task OnInput(ChangeEventArgs e)
    {
        var newVal = e.Value?.ToString();
        if (!EqualityComparer<string?>.Default.Equals(Value, newVal))
        {
            await ValueChanged.InvokeAsync(newVal);
            if (CascadedEditContext != null && ValueExpression != null)
            {
                CascadedEditContext.NotifyFieldChanged(Field);
            }
        }
    }

    private static string[]? GetMemberNames(Expression<Func<string>>? expr)
    {
        if (expr == null) return null;
        Expression? body = expr.Body;
        if (body is UnaryExpression ue) body = ue.Operand;
        var members = new System.Collections.Generic.List<string>();
        while (body is MemberExpression me)
        {
            members.Add(me.Member.Name);
            body = me.Expression;
        }
        members.Reverse();
        return members.ToArray();
    }

    private static object? GetParentInstance(Expression<Func<string>>? expr)
    {
        if (expr == null) return null;
        Expression? body = expr.Body;
        if (body is UnaryExpression ue) body = ue.Operand;
        if (body is MemberExpression leaf)
        {
            var parentExpr = leaf.Expression;
            if (parentExpr == null) return null;
            try
            {
                var getter = Expression.Lambda<Func<object>>(Expression.Convert(parentExpr, typeof(object)));
                return getter.Compile().Invoke();
            }
            catch
            {
                return null;
            }
        }
        return null;
    }
}